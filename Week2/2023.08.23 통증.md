# 🧩 구름톤 챌린지 8일차: 통증

</br>

## 1. 문제정보
![image](https://github.com/hj4645/goormChallenge/assets/134211096/95bd9514-8702-4b3b-9cbe-55849e4535c0)

  <details>
  <summary>출력 형식 자세히</summary>
  
![image](https://github.com/hj4645/goormChallenge/assets/134211096/b711345d-d1c2-4a79-9fe6-7a9a8d6324b7)
  </details>
</br>

## 2. 풀이
### 2.1. 사용 언어
![Static Badge](https://img.shields.io/badge/python-%233776AB?style=for-the-badge&logo=python&logoColor=white)

### 2.2. 계획 & 구현
#### 💡 조건에 따라 반드시 구현해야 하는 기능

- 입력받기: 통증 수치(N)에 대한 정보를 입력받는다.
  - int(input()) 함수 사용

- 함수 정의: 통증 수치를 0으로 만들기 위해 사용되는 아이템의 최소 개수를 계산하는 함수 def count_until_zero(N)
  - 통증을 감소시키는 3종류의 아이템 bandage, medicine, painkiller를 각각 b, m, p라 하고, 각각 1, 7, 14 를 할당
  - N이 0이 될 때까지 N을 p(14), m(7), b(1) 순으로 계속 줄여나가면서 N이 1회 감소할 때마다 `count += 1`를 통해 아이템 사용 횟수를 count한다.
 
- 출력: 아이템 bandage(b), medicine(m), painkiller(p)를 최소한으로 사용한 횟수 `result = count_until_zero(N)`를 출력한다.
  - `print(result)`
  
#### 💡 완성된 코드

  <details>
  <summary>전체 코드 열기</summary>

```python
def count_until_zero(N):
    b, m, p = 1, 7, 14  # 주어진 값
    count = 0

    while N > 0:
        if N >= p:
            N -= p
        elif N >= m:
            N -= m
        else:
            N -= b
        count += 1

    return count

N = int(input())
result = count_until_zero(N)
print(result)
```
  </details>

</br>

## 3. 결과

#### ⭕통과!⭕
![image](https://github.com/hj4645/goormChallenge/assets/134211096/33207a69-a721-4a54-836f-e257a3534dd8)

</br>

## 4. Plus+@
<details>
  <summary> 1. 그리디(Greedy) 알고리즘 사용 시 발생하는 문제점에 대해 </summary>
  
  - 그리디 알고리즘은 현재 상태에서 매 순간마다 최적의 선택을 하는 것을 목표로 하지만, 이러한 방식이 항상 전체적으로 최적해를 보장하지는 않는다. 
  - 문제1: 로컬 최적해와 전역 최적해의 간극
    - 그리디 알고리즘이 항상 현재 상황에서 최적의 선택을 하지만, 이러한 선택들이 모여 전체적으로는 최적해를 보장하지 않을 수 있다. 매 순간의 최적해가 모여도 전체적으로는 최적이 아닐 수 있기 때문.
  - 문제2: 순간적 선택의 영향
    - 그리디 알고리즘이 매 순간 최선의 선택을 하기 때문에, 이후의 선택에 대한 고려가 제대로 이루어지지 않을 수 있다. 일부 선택이 이후의 선택에 부정적인 영향을 줄 수 있는 것
  - 문제3: 최적 부분 구조가 성립하지 않는 경우
    - 최적 부분 구조가 깨져 있는 문제에서 그리디 알고리즘을 적용하면 정확한 최적해를 찾기 어려울 수 있다.
  - 문제4: 증명의 어려움
    - 그리디 알고리즘은 최적해임을 증명하는 것이 어려울 수 있다. 문제에 따라 그리디 접근이 최적임을 증명하기 위해서는 많은 수학적 논리가 필요할 수 있다.
  - 문제5: 문제에 따라 적용되지 않을 수 있음
    - 어떤 문제는 그리디 알고리즘으로 해결할 수 있지만, 어떤 문제는 그리디 알고리즘으로 해결이 불가능한 경우도 있다. 이는 문제의 특성에 따라 다르다.
</details>

<details>
  <summary>2. 느낀점💬</summary>
  
  - 다이나믹 프로그래밍 방법과 그리디 알고리즘 중 그리디 알고리즘을 사용하는 편이 좀 더 간결하고 직관적으로 이해하기 쉬운 코드의 형태를 띌 수 있을 것 같아 그리디 알고리즘을 사용하여 문제를 해결하였다.
  - 말 그대로 주어진 통증 수치(N)와 아이템으로 줄일 수 있는 수치를 가장 큰 수부터 비교해가며 빼고, 결국 이 뺄셈의 횟수가 아이템 사용 횟수와 동일하기에 해당 방식을 채용하였다.
  - 그런데 그리디 알고리즘은 모든 문제에서 통용될 수 있는 것은 아니며, 때로 하위 문제들의 결과를 저장하거나 재사용해야 하는 경우에는 다이나믹 프로그래밍 채용하는 것이 좋다.
  - 알고리즘 문제를 해결하는데에는 참 많은 접근 방식과 풀이 방법이 존재하는 것 같다.
  - 반드시 복잡한 알고리즘을 사용해야 하는 문제도 있겠지만, 가능하다면 최대한 간단하고 누구나 이해하기 쉬운 알고리즘을 떠올려 문제를 풀어나가고 싶다. 그러기 위해서는 더 많은 연습과 노력이 필요하겠다.
</details>
